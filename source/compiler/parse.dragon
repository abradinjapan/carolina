[
    Parsing
]

[
    Types
]

[ parsling program - all parsable language features ]
!carolina.parsling.program(
    structures !dragon.list #carolina.parsling.structure,
    aliases !dragon.list #carolina.parsling.alias,
    functions !dragon.list #carolina.parsling.function
)

[ parsling structure - a structure ]
!carolina.parsling.structure(
    name !carolina.lexling,
    members !dragon.list #carolina.parsling.structure.argument
)

[ parsling alias - a new name given to a structure (does not include functions) ]
!carolina.parsling.alias(
    old_name !carolina.lexling,
    new_name !carolina.lexling
)

[ parsling function - a function ]
!carolina.parsling.function(
    name !carolina.lexling,
    inputs !dragon.list #carolina.parsling.function.argument,
    outputs !dragon.list #carolina.parsling.function.argument,
    scope !carolina.parsling.scope
)

[ parsling function header argument ]
!carolina.parsling.function.argument(
    name !carolina.lexling,
    type !carolina.lexling [ optional ]
)

[ parsling structure member argument ]
!carolina.parsling.structure.argument(
    name !carolina.lexling,
    type !carolina.lexling
)

[ parsling scope ]
!carolina.parsling.scope(
    name !carolina.lexling,
    condition !carolina.parsling.statement.argument,
    statements !dragon.list #carolina.parsling.statement
)

[ parsling statement ]
!carolina.parsling.statement(
    [ type ]
    type !dragon.cell #carolina.parsling.statement.type,

    [ value ]
    call !carolina.parsling.statement.call,
    offset !carolina.parsling.statement.offset,
    scope !carolina.parsling.scope
)

[ parsling function call ]
!carolina.parsling.statement.call(
    name !carolina.lexling,
    inputs !dragon.list #carolina.parsling.statement.argument,
    outputs !dragon.list #carolina.parsling.statement.argument
)

[ parsling statement arguments (at least one of either name, type, offset or string must be present) ]
!carolina.parsling.statement.argument(
    [ the type of argument ]
    argument_type !dragon.cell,

    [ the argument itself ]
    namespace !carolina.parsling.statement.namespace [ optional ],
    string !carolina.lexling, [ optional ]
    structure_type !carolina.lexling, [ optional ]
    offset !carolina.parsling.statement.offset [ optional ]
)

[ a name / member searcher ]
!carolina.parsling.statement.namespace(
    names !dragon.list #carolina.lexling
)

[ parsling offset ]
!carolina.parsling.statement.offset(
    name !carolina.lexling,
    jump_extension !carolina.lexling [ optional ]
)

[ statement types ]
!carolina.parsling.statement.types(
    call !dragon.cell,
    offset !dragon.cell,
    scope !dragon.cell
)

[ argument types ]
!carolina.parsling.statement.arguments.types(
    namespace !dragon.cell,
    string !dragon.cell,
    structure_type !dragon.cell
)

[
    Parsing
]

[ parse program ]
carolina.parse.program(lexlings !carolina.lexlings)(output !carolina.parsling.program, error !dragon.error) = {
    [ setup constants ]
    dragon.pack.increment(dragon.constant.0, dragon.constant.1)(lexling_types !carolina.lexling.types)
    dragon.set("Parsing Error: No error occured. If you're seeing this, congrats! You found a bug!")(error_message.no_error)
    dragon.set("Parsing Error: Ran out of lexlings to parse with.")(error_message.ran_out_of_lexlings)
    dragon.set("Parsing Error: Was looking for a name after an exclamation point for an alias / structure definition but nothing valid was found.")(error_message.missing_structure_definition.expected_name)
    dragon.set("Parsing Error: Was looking for an equals sign after the name of an alias / structure definition but was not found.")(error_message.missing_structure_definition.expected_equals)
    dragon.set("Parsing Error: Was looking for the start of a valid structure body or new alias name but found neither.")(error_message.missing_structure_definition.expected_something)

    [ setup blank error ]
    dragon.error.setup_blank()(error)

    [ open program ]
    carolina.open.parsling.program()(output)

    [ setup current ]
    dragon.list.calculate.content_buffer(lexlings:list)(lexlings.buffer)
    dragon.pack(lexlings.buffer, lexlings.buffer:start)(current_lexling !dragon.current)

    [ setup search loop ]
    @search dragon.always = {
        [ check for remaining lexlings ]
        [ carolina.parsing.check_for_lexling.available(current, error_message.ran_out_of_lexlings, blank_text_location, error)(in_range, out_of_range, error)
        dragon.jump.bottom(out_of_range, @dragon.master_scope)() ]

        [ check for exclamation point ]
        carolina.parse.check_for_lexling.by_type(current_lexling, lexling_types:exclamation_point, dragon.false, error_message.no_error, error)(current_lexling, lexling.ignored, found, not_found, error)
        @search.type_or_alias found = {
            [ get & check name ]
            carolina.parse.check_for_lexling.by_type(current_lexling, lexling_types:name, dragon.true, error_message.missing_structure_definition.expected_name, error)(current_lexling, structure_name, found, not_found, error)
            dragon.jump.bottom(error:occured, @dragon.master_scope)()

            [ check for equals sign ]
            carolina.parse.check_for_lexling.by_type(current_lexling, lexling_types:equals_sign, dragon.true, error_message.missing_structure_definition.expected_equals, error)(current_lexling, equals_sign, found, not_found, error)
            dragon.jump.bottom(error:occured, @dragon.master_scope)()

            [ check for exclamation, thus is an alias ]
            carolina.parse.check_for_lexling.by_type(current_lexling, lexling_types:exclamation_point, dragon.false, error_message.no_error, error)(current_lexling, lexling.ignored, found, not_found, error)
            @search.is_alias found = {
                [ get & check name ]
                carolina.parse.check_for_lexling.by_type(current_lexling, lexling_types:name, dragon.true, error_message.missing_structure_definition.expected_name, error)(current_lexling, new_structure_name, found, not_found, error)
                dragon.jump.bottom(error:occured, @dragon.master_scope)()

                [ pack alias ]
                dragon.pack(structure_name, new_structure_name)(alias !carolina.parsling.alias)

                [ append alias ]
                carolina.list.append.parsling.alias(output, alias)(output)

                [ DEBUG ]
                carolina.parse.print.alias(alias)()

                [ next lexling search ]
                dragon.jump.top(dragon.always, @search)()
            }

            [ check for parenthesis, thus is a structure ]
            carolina.parse.check_for_lexling.by_type(current_lexling, lexling_types:left_parenthesis, dragon.true, error_message.missing_structure_definition.expected_something, error)(current_lexling, lexling.ignored, found, not_found, error)
            dragon.jump.bottom(error:occured, @dragon.master_scope)()
            @search.type.structure found = {
                [ search for first structure member ]
                carolina.parse.structure.argument(current_lexling, error)(current_lexling, structure_argument, error)
                dragon.jump.bottom(error:occured, @dragon.master_scope)()

                [ open structure list ]
                dragon.set(dragon.integer.16)(increase)
                dragon.structure.byte_size(structure_argument)(structure_argument.byte_size)
                dragon.integer.multiply(increase, structure_argument.byte_size)(increase)
                dragon.list.open(increase)(structure_members)

                [ search for structure members ]
                @search.type.structure.members dragon.always = {
                    [ check for left parenthesis ]
                    carolina.parse.check_for_lexling.by_type(current_lexling, lexling_types:left_parenthesis, dragon.false, error_message.no_error, error)(current_lexling, lexling.ignored, found, not_found, error)
                    @search.type.structure.members.no_more_members found = {
                        [ pack structure ]
                        dragon.pack(structure_name, structure_members)(structure !carolina.parsling.structure)

                        [ append structure definition ]
                        carolina.list.append.parsling.structure(output, structure)(output)
                        
                        [ debug ]

                    }

                    [ check for comma ]

                    [ get member ]

                    [ jump to structure loop start ]
                }
            }
        }

        [ check for name ]
        @search.name dragon.never = {
            [ must be a function, get name ]
            [ todo ]

            [ get input arguments ]
            [ todo ]

            [ get output arguments ]
            [ todo ]

            [ check for equals sign ]
            [ todo ]

            [ parse scope ]
            [ todo ]
        }

        [ check for eof ]

        [ check for eofs ]

        [ nothing matched, syntax error ]
    }

    [ set an error from a potential error ]
    @error.set dragon.always = {
        
    }
}

[ parse a structure argument ]
carolina.parse.structure.argument(current_lexling !dragon.current, error !dragon.error)(current_lexling !dragon.current, structure_argument !carolina.parsling.structure.argument, error !dragon.error) = {
    [ setup constants ]
    dragon.pack.increment(dragon.constant.0, dragon.constant.1)(lexling_types !carolina.lexling.types)
    dragon.set("Parsing Error: Was looking for a name to start a structure member but was not found.")(error_message.invalid_structure_member.expected_name)
    dragon.set("Parsing Error: Was looking for an exclamation point to start a structure member type but was not found.")(error_message.invalid_structure_member.expected_exclamation_point)
    dragon.set("Parsing Error: Was looking for a name of a type for a structure member but was not found.")(error_message.invalid_structure_member.expected_type_name)

    [ search for name ]
    carolina.parse.check_for_lexling.by_type(current_lexling, lexling_types:name, dragon.true, error_message.invalid_structure_member.expected_name, error)(current_lexling, structure_argument:name, found, not_found, error)
    dragon.jump.bottom(error:occured, @dragon.master_scope)()

    [ search for exclamation point ]
    carolina.parse.check_for_lexling.by_type(current_lexling, lexling_types:exclamation_point, dragon.true, error_message.invalid_structure_member.expected_exclamation_point, error)(current_lexling, lexling.ignored, found, not_found, error)
    dragon.jump.bottom(error:occured, @dragon.master_scope)()

    [ search for type ]
    carolina.parse.check_for_lexling.by_type(current_lexling, lexling_types:name, dragon.true, error_message.invalid_structure_member.expected_type_name, error)(current_lexling, structure_argument:type, found, not_found, error)
}

[ get and check for lexling ]
carolina.parse.check_for_lexling.by_type(current !dragon.current, expected_type !dragon.cell, raise_error_if_occured !dragon.cell, error_message !dragon.buffer, error !dragon.error)(current !dragon.current, lexling !carolina.lexling, found !dragon.cell, not_found !dragon.cell, error !dragon.error) = {
    [ setup constants ]
    dragon.pack.null()(blank_text_location !dragon.text.location)

    [ check for no more lexlings ]
    carolina.parsing.check_for_lexling.available(current, error_message, raise_error_if_occured, blank_text_location, error)(found, not_found, error)
    dragon.jump.bottom(not_found, @dragon.master_scope)()

    [ get lexling ]
    carolina.current.get.lexling_from_current(current)(lexling)

    [ check type ]
    carolina.check.lexling.type(lexling, expected_type)(found, not_found)

    [ advance current if found ]
    @advance found = {
        carolina.current.advance.lexling(current)(current)
    }
}

[ check for remaining lexlings ]
carolina.parsing.check_for_lexling.available(current !dragon.current, error_message !dragon.buffer, raise_error_if_occured !dragon.cell, location !dragon.text.location, error !dragon.error)(in_range !dragon.cell, out_of_range !dragon.cell, error !dragon.error) = {
    [ check for valid range ]
    dragon.current.within_range(current)(in_range, out_of_range)
    @ran_out_of_lexlings out_of_range = {
        @raise_error_if_occured raise_error_if_occured = {
            [ generate error ]
            carolina.error.generate(error_message, location)(error)
        }
    }
}

[ get lexling from current ]
carolina.current.get.lexling_from_current(current !dragon.current)(lexling !carolina.lexling) = {
    [ get byte size ]
    dragon.structure.byte_size(lexling)(lexling_length)

    [ calculate end address ]
    dragon.buffer.calculate.end_address(current:progress, lexling_length)(end_address)
    dragon.pack(current:progress, end_address)(lexling_buffer !dragon.buffer)

    [ convert ]
    dragon.buffer_to_structure(lexling_buffer)(lexling !carolina.lexling)
}

[ advance to next lexling ]
carolina.current.advance.lexling(current !dragon.current)(current !dragon.current) = {
    [ calculate byte size ]
    dragon.pack.null()(lexling !carolina.lexling)
    dragon.structure.byte_size(lexling)(lexling.byte_size)

    [ advance current ]
    dragon.integer.add(current:progress, lexling.byte_size)(current:progress)
}

[ check lexling type ]
carolina.check.lexling.type(lexling !carolina.lexling, expected_type !dragon.cell)(valid !dragon.cell, invalid !dragon.cell) = {
    [ check type ]
    dragon.integer.within_range(expected_type, lexling:type, expected_type)(valid, invalid)
}

[ open parsling program ]
carolina.open.parsling.program()(program !carolina.parsling.program) = {
    [ setup baked data ]
    dragon.set(dragon.integer.2048)(multiplier)
    dragon.pack.null()(structure !carolina.parsling.structure)
    dragon.pack.null()(alias !carolina.parsling.alias)
    dragon.pack.null()(function !carolina.parsling.function)

    [ calculate increases ]
    dragon.structure.byte_size(structure)(structure.byte_size)
    dragon.structure.byte_size(alias)(alias.byte_size)
    dragon.structure.byte_size(function)(function.byte_size)
    dragon.integer.multiply(structure.byte_size, multiplier)(structure.increase)
    dragon.integer.multiply(alias.byte_size, multiplier)(alias.increase)
    dragon.integer.multiply(function.byte_size, multiplier)(function.increase)

    [ open lists ]
    dragon.list.open(structure.increase)(program:structures)
    dragon.list.open(alias.increase)(program:aliases)
    dragon.list.open(function.increase)(program:functions)
}

[
    Parsling Type List Functionality
]

[ append alias ]
carolina.list.append.parsling.alias(program !carolina.parsling.program, alias !carolina.parsling.alias)(program !carolina.parsling.program) = {
    [ append data ]
    carolina.list.append.lexling(program:aliases, alias:old_name)(program:aliases)
    carolina.list.append.lexling(program:aliases, alias:new_name)(program:aliases)
}

[ append structure ]
carolina.list.append.parsling.structure(program !carolina.parsling.program, structure !carolina.parsling.structure)(program !carolina.parsling.program) = {
    [ append data ]
    carolina.list.append.lexling(program:structures, structure:name)(program:structures)
    dragon.list.append.list(program:structures, structure:members)(program:structures)
}

[
    Printing
]

[ print an alias ]
carolina.parse.print.alias(alias !carolina.parsling.alias)() = {
    dragon.set("Alias: ")(message)
    dragon.print.buffer_as_string(message)()
    carolina.lex.print_lexling(alias:old_name)()
    carolina.lex.print_lexling(alias:new_name)()
    dragon.print.new_line()()
}

[ print a structure ]
carolina.parse.print.structure(structure !carolina.parsling.structure)() = {
    [ print header & name ]
    dragon.set("Structure: ")(message)
    dragon.print.buffer_as_string(message)()
    carolina.lex.print_lexling(structure:name)()
    dragon.print.new_line()()

    [ print arguments ]
    @print dragon.always = {
        
    }
}

[ print a structure argument ]
carolina.parse.print.structure_argument(argument !carolina.parsling.structure.argument)() = {
    dragon.set("Structure Argument: ")(message)
    dragon.print.buffer_as_string(message)()
    carolina.lex.print_lexling(argument:name)()
    carolina.lex.print_lexling(argument:type)()
    dragon.print.new_line()()
}
