[
    Lexing
]

[ lexlings ]
!carolina.lexlings(
    list !dragon.list [ !carolina.lexling ]
)

[ open lexlings ]
carolina.lexlings.open()(lexlings !carolina.lexlings) = {
    [ create dummy lexling ]
    dragon.pack.null()(lexling.dummy !carolina.lexling)

    [ calculate increase ]
    dragon.set(dragon.integer.1024)(increase)
    dragon.structure.byte_size(lexling.dummy)(lexling.size)
    dragon.integer.multiply(increase, lexling.size)(increase)

    [ open list ]
    dragon.list.open(increase)(lexlings:list)
}

[ close lexlings ]
carolina.lexlings.close(lexlings !carolina.lexlings)() = {
    [ close list ]
    dragon.list.close(lexlings:list)()
}

[ lexling ]
!carolina.lexling(
    type !dragon.cell,
    value !dragon.buffer,
    location !dragon.text.location
)

[ lexling types ]
!carolina.lexling.types(
    invalid !dragon.cell,
    left_parenthesis !dragon.cell,
    right_parenthesis !dragon.cell,
    left_curly_bracket !dragon.cell,
    right_curly_bracket !dragon.cell,
    colon !dragon.cell,
    comma !dragon.cell,
    exclamation_point !dragon.cell,
    at !dragon.cell,
    equals_sign !dragon.cell,
    name !dragon.cell,
    string !dragon.cell,
    end_of_file !dragon.cell,
    end_of_files !dragon.cell
)

[ lex files ]
carolina.lex(buffers !dragon.buffer)(lexlings !carolina.lexlings, error !dragon.error) = {
    [ setup lexling type values ]
    dragon.pack.increment(dragon.constant.0, dragon.constant.1)(types !carolina.lexling.types)

    [ setup characters ]
    dragon.set(dragon.integer.32)(whitespace.range.end)
    dragon.pack(dragon.constant.0, whitespace.range.end)(whitespace !dragon.buffer)
    dragon.set(dragon.hexadecimal.0A)(new_line)
    dragon.set(dragon.hexadecimal.7B)(left_curly_bracket)
    dragon.set(dragon.hexadecimal.7D)(right_curly_bracket)
    dragon.set(dragon.hexadecimal.28)(left_parenthesis)
    dragon.set(dragon.hexadecimal.29)(right_parenthesis)
    dragon.set(dragon.hexadecimal.5B)(left_square_bracket)
    dragon.set(dragon.hexadecimal.5D)(right_square_bracket)
    dragon.set(dragon.hexadecimal.22)(double_quote)
    dragon.set(dragon.hexadecimal.2C)(comma)
    dragon.set(dragon.hexadecimal.3A)(colon)
    dragon.set(dragon.hexadecimal.3D)(equals_sign)
    dragon.set(dragon.hexadecimal.21)(exclamation_point)
    dragon.set(dragon.hexadecimal.40)(at)

    [ setup other data ]
    dragon.structure.byte_size(buffers)(buffer.byte_size)

    [ open lexlings ]
    carolina.lexlings.open()(lexlings)

    [ setup buffers current ]
    dragon.pack(buffers, buffers:start)(current.buffers !dragon.current)

    [ setup stats ]
    dragon.pack(dragon.constant.0, dragon.constant.1, dragon.constant.0)(current_location !dragon.text.location)

    [ loop over each individual buffer ]
    @loop.lex.buffers dragon.always = {
        [ check for condition ]
        dragon.current.within_range(current.buffers)(in_range, out_of_range)
        dragon.jump.bottom(out_of_range, @loop.lex.buffers)()

        [ get character current from buffer ]
        dragon.buffer.calculate.end_address(current.buffers:progress, buffer.byte_size)(current.buffer.end)
        dragon.pack(current.buffers:progress, current.buffer.end)(buffers_slice !dragon.buffer)
        dragon.buffer_to_structure(buffers_slice)(character_buffer !dragon.buffer)
        dragon.pack(character_buffer, character_buffer:start)(current.character !dragon.current)

        [ setup location information ]
        dragon.copy(dragon.constant.1)(current_location:line_number)
        dragon.copy(dragon.constant.0)(current_location:character_index)

        [ loop over characters ]
        @loop.lex.characters dragon.always = {
            [ check for condition ]
            dragon.current.within_range(current.character)(in_range, out_of_range)
            dragon.jump.bottom(out_of_range, @loop.lex.characters)()

            [ setup value buffer ]
            dragon.pack(current.character:progress, current.character:progress)(current_value !dragon.buffer)

            [ setup starting location ]
            dragon.copy(current_location)(starting_location)

            [ get character ]
            dragon.address_to_cell(current.character:progress, dragon.ascii_character.byte_size)(character, advancement)

            [ determine type ]
            [ check for whitespace ]
            dragon.integer.within_range(whitespace:start, character, whitespace:end)(in_range, out_of_range)
            @is_whitespace in_range = {
                [ check for newline ]
                dragon.integer.within_range(new_line, character, new_line)(in_range, out_of_range)
                @is_whitespace.new_line_detected in_range = {
                    [ increment line ]
                    dragon.integer.add(current_location:line_number, dragon.constant.1)(current_location:line_number)
                }

                [ next character ]
                dragon.integer.add(current_location:character_index, dragon.ascii_character.byte_size)(current_location:character_index)
                dragon.copy(advancement)(current.character:progress)

                [ jump to next character check ]
                dragon.jump.top(dragon.always, @loop.lex.characters)()
            }

            [ if is comment ]
            dragon.integer.within_range(left_square_bracket, character, left_square_bracket)(in_range, out_of_range)
            @comment in_range = {
                [ setup comment index ]
                dragon.copy(dragon.constant.1)(comment_depth)

                [ advance progress by one ]
                dragon.integer.add(current_location:character_index, dragon.ascii_character.byte_size)(current_location:character_index)
                dragon.copy(advancement)(current.character:progress)

                [ traverse comment characters ]
                @comment.traverse in_range = {
                    [ check to see if is at end of comment ]
                    dragon.integer.within_range(dragon.constant.0, comment_depth, dragon.constant.0)(in_range, out_of_range)
                    dragon.jump.top(in_range, @loop.lex.characters)()

                    [ check to see if is at end of file ]
                    dragon.current.within_range(current.character)(in_range, out_of_range)
                    @comment.traverse.no_more_characters out_of_range = {
                        [ error, while searching for the end of a comment the file ended unexpectedly ]
                        dragon.set("Lexing Error: While searching for the end of a comment, the file ended unexpectedly.")(temp.error_message)
                        carolina.error.generate(temp.error_message, current_location)(error)

                        [ exit loop ]
                        dragon.jump.bottom(dragon.always, @loop.lex.buffers)()
                    }

                    [ get character ]
                    dragon.address_to_cell(current.character:progress, dragon.ascii_character.byte_size)(character, advancement)

                    [ check character for depth change ]
                    dragon.integer.within_range(left_square_bracket, character, left_square_bracket)(in_range, out_of_range)
                    @comment.traverse.increase_depth in_range = {
                        [ increase depth ]
                        dragon.integer.add(comment_depth, dragon.constant.1)(comment_depth)

                        [ advance ]
                        dragon.integer.add(current_location:character_index, dragon.ascii_character.byte_size)(current_location:character_index)
                        dragon.copy(advancement)(current.character:progress)

                        [ jump back to loop start ]
                        dragon.jump.top(dragon.always, @comment.traverse)()
                    }
                    dragon.integer.within_range(right_square_bracket, character, right_square_bracket)(in_range, out_of_range)
                    @comment.traverse.decrease_depth in_range = {
                        [ decrease depth ]
                        dragon.integer.subtract(comment_depth, dragon.constant.1)(comment_depth)

                        [ advance ]
                        dragon.integer.add(current_location:character_index, dragon.ascii_character.byte_size)(current_location:character_index)
                        dragon.copy(advancement)(current.character:progress)

                        [ jump back to loop start ]
                        dragon.jump.top(dragon.always, @comment.traverse)()
                    }

                    [ check for newline ]
                    dragon.integer.within_range(new_line, character, new_line)(in_range, out_of_range)
                    @comment.traverse.new_line_detected in_range = {
                        [ increment line ]
                        dragon.integer.add(current_location:line_number, dragon.constant.1)(current_location:line_number)
                    }

                    [ advance ]
                    dragon.integer.add(current_location:character_index, dragon.ascii_character.byte_size)(current_location:character_index)
                    dragon.copy(advancement)(current.character:progress)

                    [ jump to loop top ]
                    dragon.jump.top(dragon.always, @comment.traverse)()
                }

                [ next character ]
                dragon.integer.add(current_location:character_index, dragon.ascii_character.byte_size)(current_location:character_index)
                dragon.copy(advancement)(current.character:progress)

                [ jump back to loop start ]
                dragon.jump.top(dragon.always, @loop.lex.characters)()
            }

            [ if is name ]
            carolina.lex.check.name_character(character)(in_range, out_of_range)
            @name in_range = {
                [ save starting character ]
                dragon.copy(current.character:progress)(name.start)

                [ loop over characters ]
                @name.loop dragon.always = {
                    [ check for end of file ]
                    dragon.current.within_range(current.character)(in_range, out_of_range)
                    dragon.jump.top(out_of_range, @name.no_more_characters)()

                    [ get character ]
                    dragon.address_to_cell(current.character:progress, dragon.ascii_character.byte_size)(character, advancement)

                    [ check for newline ]
                    dragon.integer.within_range(new_line, character, new_line)(in_range, out_of_range)
                    @name.new_line_detected in_range = {
                        [ increment line ]
                        dragon.integer.add(current_location:line_number, dragon.constant.1)(current_location:line_number)
                    }

                    [ check for name character ]
                    carolina.lex.check.name_character(character)(in_range, out_of_range)
                    dragon.jump.top(out_of_range, @name.no_more_characters)()

                    [ next character ]
                    dragon.integer.add(current_location:character_index, dragon.ascii_character.byte_size)(current_location:character_index)
                    dragon.copy(advancement)(current.character:progress)

                    [ jump to loop start ]
                    dragon.jump.top(dragon.always, @name.loop)()
                }

                [ setup lexling ]
                @name.no_more_characters dragon.always = {
                    [ create lexling ]
                    dragon.integer.subtract(current.character:progress, dragon.constant.1)(name.end)
                    dragon.pack(name.start, name.end)(current_value !dragon.buffer)
                    dragon.pack(types:name, current_value, starting_location)(lexling !carolina.lexling)

                    [ append lexling ]
                    carolina.list.append.lexling(lexlings:list, lexling)(lexlings:list)
                    
                    [ jump to bottom of loop ]
                    dragon.jump.top(dragon.always, @loop.lex.characters)()
                }
            }

            [ if is string ]
            dragon.integer.within_range(double_quote, character, double_quote)(in_range, out_of_range)
            @string in_range = {
                [ setup starting address ]
                dragon.copy(current.character:progress)(string.start)

                [ next character ]
                dragon.integer.add(current_location:character_index, dragon.ascii_character.byte_size)(current_location:character_index)
                dragon.copy(advancement)(current.character:progress)

                [ loop over characters to find end quote ]
                @string.loop dragon.always = {
                    [ check for end of file ]
                    dragon.current.within_range(current.character)(in_range, out_of_range)
                    @string.ran_out_of_characters out_of_range = {
                        [ error, while searching for the end of a string the file ended unexpectedly ]
                        dragon.set("Lexing Error: While searching for the end of a string, the file ended unexpectedly.")(temp.error_message)
                        carolina.error.generate(temp.error_message, current_location)(error)

                        [ exit loop ]
                        dragon.jump.bottom(dragon.always, @loop.lex.buffers)()
                    }

                    [ get character ]
                    dragon.address_to_cell(current.character:progress, dragon.ascii_character.byte_size)(character, advancement)

                    [ check for newline ]
                    dragon.integer.within_range(new_line, character, new_line)(in_range, out_of_range)
                    @string.new_line_detected in_range = {
                        [ increment line ]
                        dragon.integer.add(current_location:line_number, dragon.constant.1)(current_location:line_number)
                    }

                    [ check for double quote character ]
                    dragon.integer.within_range(double_quote, character, double_quote)(in_range, out_of_range)
                    @string.finished in_range = {
                        [ create lexling ]
                        dragon.pack(string.start, current.character:progress)(current_value !dragon.buffer)
                        dragon.pack(types:string, current_value, starting_location)(lexling !carolina.lexling)

                        [ next character ]
                        dragon.integer.add(current_location:character_index, dragon.ascii_character.byte_size)(current_location:character_index)
                        dragon.copy(advancement)(current.character:progress)

                        [ append lexling ]
                        carolina.list.append.lexling(lexlings:list, lexling)(lexlings:list)
                        
                        [ jump back to loop start ]
                        dragon.jump.top(dragon.always, @loop.lex.characters)()
                    }

                    [ next character ]
                    dragon.integer.add(current_location:character_index, dragon.ascii_character.byte_size)(current_location:character_index)
                    dragon.copy(advancement)(current.character:progress)

                    [ jump to loop start ]
                    dragon.jump.top(dragon.always, @string.loop)()
                }
            }

            [ if is single character lexling ]
            [ left curly bracket ]
            dragon.integer.within_range(left_curly_bracket, character, left_curly_bracket)(in_range, out_of_range)
            @left_curly_bracket in_range = {
                [ create lexling ]
                dragon.pack(types:left_curly_bracket, current_value, starting_location)(lexling !carolina.lexling)

                [ next character ]
                dragon.integer.add(current_location:character_index, dragon.ascii_character.byte_size)(current_location:character_index)
                dragon.copy(advancement)(current.character:progress)

                [ append lexling ]
                carolina.list.append.lexling(lexlings:list, lexling)(lexlings:list)

                [ jump back to loop start ]
                dragon.jump.top(dragon.always, @loop.lex.characters)()
            }

            [ right curly bracket ]
            dragon.integer.within_range(right_curly_bracket, character, right_curly_bracket)(in_range, out_of_range)
            @right_curly_bracket in_range = {
                [ create lexling ]
                dragon.pack(types:right_curly_bracket, current_value, starting_location)(lexling !carolina.lexling)

                [ next character ]
                dragon.integer.add(current_location:character_index, dragon.ascii_character.byte_size)(current_location:character_index)
                dragon.copy(advancement)(current.character:progress)

                [ append lexling ]
                carolina.list.append.lexling(lexlings:list, lexling)(lexlings:list)

                [ jump back to loop start ]
                dragon.jump.top(dragon.always, @loop.lex.characters)()
            }

            [ left parenthesis ]
            dragon.integer.within_range(left_parenthesis, character, left_parenthesis)(in_range, out_of_range)
            @left_parenthesis in_range = {
                [ create lexling ]
                dragon.pack(types:left_parenthesis, current_value, starting_location)(lexling !carolina.lexling)

                [ next character ]
                dragon.integer.add(current_location:character_index, dragon.ascii_character.byte_size)(current_location:character_index)
                dragon.copy(advancement)(current.character:progress)

                [ append lexling ]
                carolina.list.append.lexling(lexlings:list, lexling)(lexlings:list)

                [ jump back to loop start ]
                dragon.jump.top(dragon.always, @loop.lex.characters)()
            }

            [ right parenthesis ]
            dragon.integer.within_range(right_parenthesis, character, right_parenthesis)(in_range, out_of_range)
            @right_parenthesis in_range = {
                [ create lexling ]
                dragon.pack(types:right_parenthesis, current_value, starting_location)(lexling !carolina.lexling)

                [ next character ]
                dragon.integer.add(current_location:character_index, dragon.ascii_character.byte_size)(current_location:character_index)
                dragon.copy(advancement)(current.character:progress)

                [ append lexling ]
                carolina.list.append.lexling(lexlings:list, lexling)(lexlings:list)

                [ jump back to loop start ]
                dragon.jump.top(dragon.always, @loop.lex.characters)()
            }

            [ colon ]
            dragon.integer.within_range(colon, character, colon)(in_range, out_of_range)
            @colon in_range = {
                [ create lexling ]
                dragon.pack(types:colon, current_value, starting_location)(lexling !carolina.lexling)

                [ next character ]
                dragon.integer.add(current_location:character_index, dragon.ascii_character.byte_size)(current_location:character_index)
                dragon.copy(advancement)(current.character:progress)

                [ append lexling ]
                carolina.list.append.lexling(lexlings:list, lexling)(lexlings:list)

                [ jump back to loop start ]
                dragon.jump.top(dragon.always, @loop.lex.characters)()
            }

            [ equals sign ]
            dragon.integer.within_range(equals_sign, character, equals_sign)(in_range, out_of_range)
            @equals_sign in_range = {
                [ create lexling ]
                dragon.pack(types:equals_sign, current_value, starting_location)(lexling !carolina.lexling)

                [ next character ]
                dragon.integer.add(current_location:character_index, dragon.ascii_character.byte_size)(current_location:character_index)
                dragon.copy(advancement)(current.character:progress)

                [ append lexling ]
                carolina.list.append.lexling(lexlings:list, lexling)(lexlings:list)

                [ jump back to loop start ]
                dragon.jump.top(dragon.always, @loop.lex.characters)()
            }

            [ exclamation point ]
            dragon.integer.within_range(exclamation_point, character, exclamation_point)(in_range, out_of_range)
            @exclamation_point in_range = {
                [ create lexling ]
                dragon.pack(types:exclamation_point, current_value, starting_location)(lexling !carolina.lexling)

                [ next character ]
                dragon.integer.add(current_location:character_index, dragon.ascii_character.byte_size)(current_location:character_index)
                dragon.copy(advancement)(current.character:progress)

                [ append lexling ]
                carolina.list.append.lexling(lexlings:list, lexling)(lexlings:list)

                [ jump back to loop start ]
                dragon.jump.top(dragon.always, @loop.lex.characters)()
            }

            [ at ]
            dragon.integer.within_range(at, character, at)(in_range, out_of_range)
            @at in_range = {
                [ create lexling ]
                dragon.pack(types:at, current_value, starting_location)(lexling !carolina.lexling)

                [ next character ]
                dragon.integer.add(current_location:character_index, dragon.ascii_character.byte_size)(current_location:character_index)
                dragon.copy(advancement)(current.character:progress)

                [ append lexling ]
                carolina.list.append.lexling(lexlings:list, lexling)(lexlings:list)

                [ jump back to loop start ]
                dragon.jump.top(dragon.always, @loop.lex.characters)()
            }

            [ comma ]
            dragon.integer.within_range(comma, character, comma)(in_range, out_of_range)
            @comma in_range = {
                [ create lexling ]
                dragon.pack(types:comma, current_value, starting_location)(lexling !carolina.lexling)

                [ next character ]
                dragon.integer.add(current_location:character_index, dragon.ascii_character.byte_size)(current_location:character_index)
                dragon.copy(advancement)(current.character:progress)

                [ append lexling ]
                carolina.list.append.lexling(lexlings:list, lexling)(lexlings:list)

                [ jump back to loop start ]
                dragon.jump.top(dragon.always, @loop.lex.characters)()
            }

            [ error, no lexling was matched ]
            dragon.set("Lexing Error: No valid lexling was matched.")(temp.error_message)
            carolina.error.generate(temp.error_message, current_location)(error)

            [ exit loop ]
            dragon.jump.bottom(dragon.always, @loop.lex.buffers)()
        }

        [ append eof lexling ]
        dragon.set("[end_of_file]")(value)
        dragon.pack(types:end_of_file, value, current_location)(lexling !carolina.lexling)
        carolina.list.append.lexling(lexlings:list, lexling)(lexlings:list)

        [ next buffer ]
        dragon.integer.add(current.buffers:progress, buffer.byte_size)(current.buffers:progress)
        dragon.integer.add(current_location:file_index, dragon.constant.1)(current_location:file_index)

        [ jump back to top for next buffer ]
        dragon.jump.top(dragon.always, @loop.lex.buffers)()
    }

    [ append eofs lexling ]
    dragon.set("[end_of_files]")(value)
    dragon.pack(types:end_of_files, value, current_location)(lexling !carolina.lexling)
    carolina.list.append.lexling(lexlings:list, lexling)(lexlings:list)
}

[ append lexling ]
carolina.list.append.lexling(list !dragon.list, data !carolina.lexling)(list !dragon.list) = {
    [ append members ]
    dragon.list.append.cell(list, data:type)(list)
    dragon.list.append.buffer(list, data:value)(list)
    dragon.list.append.text.location(list, data:location)(list)
}

[ check for name character ]
carolina.lex.check.name_character(character !dragon.cell)(valid !dragon.cell, invalid !dragon.cell) = {
    [ setup character ranges ]
    dragon.set(dragon.hexadecimal.61)(lowercase.start)
    dragon.set(dragon.hexadecimal.7A)(lowercase.end)
    dragon.set(dragon.hexadecimal.41)(uppercase.start)
    dragon.set(dragon.hexadecimal.5A)(uppercase.end)
    dragon.set(dragon.hexadecimal.30)(decimal_digits.start)
    dragon.set(dragon.hexadecimal.39)(decimal_digits.end)
    dragon.set(dragon.hexadecimal.5F)(underscore)
    dragon.set(dragon.hexadecimal.2E)(period)

    [ perform checks ]
    dragon.integer.within_range(lowercase.start, character, lowercase.end)(valid, invalid)
    dragon.jump.bottom(valid, @dragon.master_scope)()
    dragon.integer.within_range(uppercase.start, character, uppercase.end)(valid, invalid)
    dragon.jump.bottom(valid, @dragon.master_scope)()
    dragon.integer.within_range(decimal_digits.start, character, decimal_digits.end)(valid, invalid)
    dragon.jump.bottom(valid, @dragon.master_scope)()
    dragon.integer.within_range(underscore, character, underscore)(valid, invalid)
    dragon.jump.bottom(valid, @dragon.master_scope)()
    dragon.integer.within_range(period, character, period)(valid, invalid)
}

[ print lexlings ]
carolina.lex.print_lexlings(lexlings !carolina.lexlings)() = {
    [ setup common strings ]
    dragon.set("Lexlings:%0a;")(header)
    dragon.set("----------%0a;")(footer)

    [ setup common data ]
    dragon.pack.null()(blank_lexling !carolina.lexling)
    dragon.structure.byte_size(blank_lexling)(lexling.byte_size)

    [ print lexlings ]
    [ print header ]
    dragon.print.buffer_as_string(header)()

    [ get current ]
    dragon.list.calculate.content_buffer(lexlings:list)(content_buffer)
    dragon.pack(content_buffer, content_buffer:start)(current !dragon.current)

    [ loop over lexlings ]
    @loop dragon.always = {
        [ check current ]
        dragon.current.within_range(current)(in_range, out_of_range)
        dragon.jump.bottom(out_of_range, @loop)()

        [ get lexling ]
        dragon.buffer.calculate.end_address(current:progress, lexling.byte_size)(lexling.end)
        dragon.pack(current:progress, lexling.end)(structure_buffer !dragon.buffer)
        dragon.buffer_to_structure(structure_buffer)(lexling !carolina.lexling)

        [ print lexling ]
        carolina.lex.print_lexling(lexling)()
        dragon.print.new_line()()

        [ next lexling ]
        dragon.integer.add(current:progress, lexling.byte_size)(current:progress)

        [ jump to loop start ]
        dragon.jump.top(dragon.always, @loop)()
    }

    [ print footer ]
    dragon.print.buffer_as_string(footer)()
}

[ print a lexling ]
carolina.lex.print_lexling(lexling !carolina.lexling)() = {
    [ setup common strings ]
    dragon.set("{ ")(header)
    dragon.set(", ")(separator)
    dragon.set("%22;")(quote)
    dragon.set(" }")(footer)

    [ print lexling ]
    dragon.print.buffer_as_string(header)()
    dragon.print.integer.unsigned(lexling:type)()
    dragon.print.buffer_as_string(separator)()
    dragon.print.buffer_as_string(quote)()
    dragon.print.buffer_as_string(lexling:value)()
    dragon.print.buffer_as_string(quote)()
    dragon.print.buffer_as_string(separator)()
    dragon.print.buffer_as_string(header)()
    dragon.print.integer.unsigned(lexling:location:file_index)()
    dragon.print.buffer_as_string(separator)()
    dragon.print.integer.unsigned(lexling:location:line_number)()
    dragon.print.buffer_as_string(separator)()
    dragon.print.integer.unsigned(lexling:location:character_index)()
    dragon.print.buffer_as_string(footer)()
    dragon.print.buffer_as_string(footer)()
}
